# objective-c的arc


# 1 gc的自我理解 
从语言层面看，有的语言开发需要程序员自己去申请和释放内存，有的语言只需要程序员申请内存，而不必自己去释放。通常把语言层面的内存自动释放理解为自动内存管理，也就是语言带有gc（垃圾回收）功能。

常见的gc算法有 引用计数法（Reference Counting）, 标记-清除算法(Mark-Sweep), 复制算法（Copying），标记-压缩算法（Mark-Compact), 增量算法(Incremental Collecting), 分代算法(Generational Collecting)。 
这些算法没有哪一个是最优算法。有的语言会综合使用多种算法来实现自己的gc。


c语言:  几乎是元老级别的编程语言了，那个时代自然没有gc功能。
c++语言:  发明于80年代，但是走到1998年才有了第一个标准c++98，第二次标准化竟是13年后的c++11。可是说是进展相当缓慢。 c++98当然也没有gc，到了2011年的c++11有了所谓的智能指针，即smart_ptr，其中最为著名的是std::shared_ptr和std::weak_ptr。智能指针也就是使用引用计数（ Reference Counting ）算法处理内存总是，笔者认为这是相对比较原始的管理方式，需要程序员经常介入，但是相比c语言已经是一大进步。

java语言:  创立于90年代，于1996年发布jdk1.0。虽然晚于c/c++，但是其发展速度超过了其它大部分语言。而笔者认为java中的gc在目前的编程语言中已经处理领先地位了。据说java中使用了多种算法来实现gc，笔者对此没有深入研究过。

go语言：go是09年宣布推出的一门非常新的开发语言，至今只有6年。目前最新版本是刚刚推出的1.5版本。go的动态特性有点类似于java，静态语言中含有某些动态特性。之前版本go的gc一直饱受诟病，据说这次发布的1.5版本改进的gc倍受期待。笔者认为其gc的能力和java语言gc的类比差了几条街，不对作为一门新生的语言，未来依然值得期待。



#2 arc与gc的区别 
简单的说，arc是编译期 objective-c的编译器帮我们做的预处理。而gc是运行期运行时帮我们做的内存回收。如果按照现代语言的谁知来说，笔者认为arc不属于gc的范畴。 这或者不太准确，不过可以理解成，类似java、python及go等这些编程语言，几乎完全不用程序员自己释放内存。而开启使用arc的objective-c语言，依然需要程序员小心的处理内存总是，由于arc的本质还是smart_ptr，所以最主要的问题依然是循环引用带来的一系列总是。


#3 objective-c中的mrc与arc 
mrc我的理解就是对c++中的smart_ptr做了一次简单的包装，而arc是在mrc的手动基础上变成了自动，编译器在代码中自动插入了mrc时代手动添加的内存释放代码。然而smart_ptr的最麻烦的问题终究是要面对的，即循环引用。 另外一个比较麻烦的总是是，开启了arc的项目与老的未开启arc的项目可能会存在相容困难。

xcode6以上新建的项目已经默认开启arc，可以在Build Settings中进行关闭。苹果已经强烈建议新项目使用arc，所以为了避免麻烦应该使用arc。不使用arc的情况通常是引用了一些旧项目，幸好可以通过设置编译参数 -fno-arc 来对单个文件关闭arc。


传统的使用mrc的规则是，

    1. 如果你alloc、new、copy或者retain一个对象，你必须release或者autorelease它。
    2. 如果你在此之外获得一个对象，但你需要它在内存中存在更长时间，你必须retain 或者copy它。当然，最后你必须release/autorelease它。


#4 使用arc

